# mipt-caos
Это решение задач из курса АКОСа на факультете ФИВТ МФТИ. Использовать на свой страх и риск. Не забывайте, что антиплагиат будет запущен, так что копировать и вставлять крайне не рекомендуется.

---

Задача 6_2 является копипастой из машинного кода, использовать не рекомендуется.
Отсутствуют задачи 11_3 и 11_4 14_2 из курса. Ассемблерный код можно копировать, меня названия регистров и меток, плагиат это не чекает.


### Problem sm02-0: c/ints/satsum

Реализовать функцию с прототипом:

uint16_t satsum(uint16_t x, uint16_t y);

которая выполняет сложение с насыщением, то есть, в случае целочисленного переполнения возвращает максимально возможное целое число для данного типа данных.

В коде программы запрещено использовать константы, отличные от 0 и 1.

Запрещено использовать платформо-зависимые или компиляторо-зависимые функции, типы данных с повышенной разрядностью или вещественные типы даннх. 


### Problem sm02-1: c/ints/bitset-calc

Реализуйте калькулятор выражений над множествами в обратной польской записи.

На стандартном потоке ввода задается последовательность, состоящая из символов-значений, и символов-операций.

Значениями являются цифры от 0 до 9, и буквы английского алфавита (заглавные и строчные). Последовательности значений кодируют множества из 62 элементов.

Операциями являются:

    & - пересечение множеств;
    | - объединение множеств;
    ^ - симметрическая разность;
    ~ - дополнение текущего результата до полного множества.

В начальный момент времени, множество-результат является пустым. При чтении символов со стандартного потока ввода, когда встречается символ операции, то эта операция применяется к множеству-результату и последнему прочитанному множеству (как в обратной польской записи).

Вывести на экран полученное итоговое значение множества в нормализованной форме: сначала цифры, затем заглавные буквы, потом - строчные (упорядоченные по алфавиту).

Для хранения множеств использовать, суммарно, не более 16 байт памяти.


### Problem sm02-2: c/texts/utf8-count-symbols

На стандартном потоке ввода подается последовательность символов в кодировке UTF-8.

Посчитать количество символов, которые могут быть представлены в кодирове ASCII, и количество символов, которые не могут быть представлены в этой кодировке.

На стандартный поток вывода вывести последовательно два эти числа.

В случае ошибки декодирования потока данных, необходимо вывести результаты подсчёта, полученные на момент обнаружения ошибки, и завершить работу программы с кодом ошибки 1.

Запрещается использовать какие-либо функции стандартной библиотеки, за исключением функций ввода. Используйте только битовые операции.

Не забывайте о том, что символ перевода строки \n является легальным ASCII-символом.


### Problem sm03-0: asm-arm/basics/expression

Реализуйте функцию с меткой f, которая вычисляет значение выражения y=Ax2+Bx+C

Значения A, B, C и x хранятся, соответсвенно, в регистрах r0, r1, r2 и r3.

Результат вычисления выражения сохраните в регистре r1.

Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.

Использовать оперативную память запрещено, - можно использовать только регистры.


### Problem sm03-1: asm-arm/basics/memaccess

Реализуйте на языке ассемблера ARM функцию с сигнатурой:

int summ(int x0, int N, int *X)

Функция должна вычислять значение x0+∑xi, где 0<e;i<N


### Problem sm03-2: asm-arm/basics/eqsolution

Реализуйте функцию solve, с прототипом

int solve(int A, int B, int C, int D);
      

которая находит минимальное значение x ∈[0,254], которое является одним из корней уравнения: Ax3+Bx2+Cx+D=0.

Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.

Не забывайте про сохраняемые регистры; можно использовать для этого память на стеке.

Гарантируется, что на тестовых данных существует целочисленное решение.


### Problem sm04-0: asm-arm/structs/simplestruct

Заданы описание структуры и прототип функции:

#include <stdint.h>

typedef struct {
    uint8_t  u8;
    uint16_t u16;
    uint32_t u32;
} values_t;

extern uint64_t
calculate(const values_t *values);
      

Реализуйте на языке ассемблера ARM-32 эту функцию, которая вычисляет значение values->u8 + values->u16 +  values->u32.

Запрещается выделять дополнительную память на стеке, для решения этой задачи достаточно только четырех регистров.

Процессор работает в режиме Little-Endian, используются стандартные соглашения о вызовах gnueabi и стандартные Си-соглашения о выравнивании.


### Problem sm04-1: generic/ieee754/classify

Реализуйте функцию с прототипом:

typedef enum {
    PlusZero      = 0x00,
    MinusZero     = 0x01,
    PlusInf       = 0xF0,
    MinusInf      = 0xF1,
    PlusRegular   = 0x10,
    MinusRegular  = 0x11,
    PlusDenormal  = 0x20,
    MinusDenormal = 0x21,
    SignalingNaN  = 0x30,
    QuietNaN      = 0x31
} float_class_t;

extern float_class_t
classify(double *value_ptr);
      

которая классифицирует специальные значения вещественного числа, на которое указывает value_ptr, в соответствии со стандартом IEEE 754.

При решении допускается использовать только побитовые операции, включая сдвиги.


### Problem sm04-2: generic/ieee754/fitint

Реализуйте функцию с прототипом:

extern int
check_int(uint32_t u32); /* retval: 0 - false, 1 - true */

которая проверяет, может ли число u32 быть представлено типом float:

float f = u32;
uint64_t y = f;
assert(u32==y);
      

Функция должна вернуть 1, если число может быть представлено типом float, или 0, - если не может.

Допускается исользовать только побитовые операции.


### Problem sm04-3: asm-arm/structs/fieldsort

Заданы описание структуры и прототип функции:

typedef struct Person {
    uint32_t  id;
    uint8_t   age;
    char      first_name[20];
    char      last_name[20];
} person_t;

extern void
sort_by_age(int N, person_t *persons);

Реализуйте функию sort_by_age, которая сортирует массив persons из N элементов в порядке возрастания поля age.

Можно использовать любой алгоритм сортировки, в том числе имеющий сложность O(N2).


### Problem sm05-0: asm-arm/basics/globalvars

Реализуйте функцию calculate, которая вычисляет значение выражения: R=(A*B)+(C*D), где A, B, C, и D - это глобальные переменные типа uint32_t, объявленные во внешнем модуле компиляции, а R, - глобальная переменная типа uint32_t в текущем модуле компиляции.


### Problem sm05-1: asm-arm/basics/format_io

Реализуйте программу, которая вычисляет сумму двух целых десятичных чисел. Размер типа равен размеру машинного слова.

Можно использовать функции стандартной библиотеки языка Си scanf и printf.

В качестве точки входа можно считать функцию main.


### Problem sm05-2: asm-arm/basics/char-filter-digits

Напишите программу, которая читает со стандартного потока ввода последовательность символов, и выводит только те из них, которые являются десятичными цифрами от 0 до 9.

Можно использовать функции стандартной библиотеки языка Си: fgetc и fputc.

В качестве точки входа можно считать функцию main.


### Problem sm05-3: asm-arm/basics/reverse-print-chars

Реализуйте программу, которая считывает символы со стандартного потока ввода, а затем выводит их в обратном порядке.

Можно использовать функции стандартной библиотеки языка Си: fgetc, fputc, realloc и free.

В качестве точки входа можно считать функцию main.


### Problem sm06-0: asm-x86/basics

Реализуйте две функции на языке ассемблера x86 (IA-32) с сигнатурами:

extern int N;
extern int *A;
extern int *B;
extern int *R;

extern void summ();
extern void everyday795(int X, int Y);
      

Первая функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.

Вторая функция:

    вводит с клавиатуры знаковое целое число;
    умножает его на X;
    прибавляет к нему Y;
    выводит результат на экран.



### Problem sm06-1: asm-x86/arrays

Реализуйте функцию на языке ассемблера x86 (IA-32) с сигнатурой:

extern void summ(int N, const int *A, const int *B, int *R);
      

Функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.

Память для хранения массива-результата уже выделена.


### Problem sm06-2: asm-x86/mergesort

Реализуйте функцию на языке ассемблера x86 (IA-32) с сигнатурой:

exten void mergesort(int from, int to, const int *in, int *out);
      

Функция выполняет сортировку целых чисел слиянием (Merge Sort).

Параметры from и to - это индексы левой и правой границ областей сортировки; in - исходный массив, out - указатель на выделенную память для хранения результата.

Используйте память только на стеке, использование кучи запрещено.


### Problem sm07-0: asm-x86/fpu-sse/fpu-sse-intro

Реализуйте на языке ассемблера x86 (IA-32) две функции с сигнатурами:

extern double
calc(double A, double B, double C, int D);

extern void
vector_sum(int N, const float *A, const float *B, float *R);

Первая функция вычисляет значение выражения (A+B)/(C+D) и возвращает результат. Можно использовать как вычисления с помощью i387 FPU, так и с помощью инструкций SSE.

Вторая функция вычисляет поэлементную сумму R[i]=A[i]+B[i]. Гарантируется, что число N больше нуля и кратно 4, а адреса массивов выровнены в памяти по границе 32 байта. Используйте векторные инструкции для вычисления. 


### Problem sm07-1: asm-x86/fpu-sse/trig-macloren-series

Реализуйте на языке ассемблера x86 (IA-32) функцию с сигнатурой:

extern double my_sin(double x)

которая вычисляет значение sin(x).

Запрещено использовать встроенные тригонометрические инструкции.

Для вычислений используйте известный вам из курса Математического анализа способ разложения функции в ряд. Точность результата должна быть маскимально возможной для типа данных double. 


### Problem sm07-2: asm-x86/fpu-sse/vector-dot-product

Реализуйте на языке ассемблера x86 (IA-32) функцию с сигнатурой:

extern float dot_product(int N, const float *A, const float *B);

которая вычисляет скалярное произведение векторов A и B.

Гарантируется, что N больше нуля, но не гарантируется, что N кратно четырём.

Значения исходных векторов хранятся в произвольных адресах памяти, поэтому выравнивание для них не гарантируется.

Необходимо минимизировать количество выполняемых вычислительных инструкций, используя векторные вычисления. Доступен набор команд SSE 4.2.


